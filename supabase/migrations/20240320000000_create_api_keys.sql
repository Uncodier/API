-- Drop existing objects if they exist
DROP TABLE IF EXISTS api_keys CASCADE;
DROP TYPE IF EXISTS key_status CASCADE;
DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;
DROP FUNCTION IF EXISTS expire_old_api_keys() CASCADE;
DROP FUNCTION IF EXISTS update_api_key_last_used() CASCADE;
DROP FUNCTION IF EXISTS rollback_api_keys() CASCADE;

-- Create API Keys table and related functions
CREATE TYPE key_status AS ENUM ('active', 'expired', 'revoked');

-- Create API Keys table
CREATE TABLE api_keys (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    key_hash TEXT NOT NULL,           -- Will store the hash generated by the application
    prefix VARCHAR(50) NOT NULL,      -- Visible prefix of the key
    user_id UUID NOT NULL,            -- Reference to the user who created the key
    site_id UUID NOT NULL,            -- Reference to the site this key belongs to
    status key_status DEFAULT 'active',
    scopes TEXT[] NOT NULL,           -- Array of permission scopes
    last_used_at TIMESTAMPTZ,         -- Track last usage
    expires_at TIMESTAMPTZ NOT NULL,  -- Expiration date
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB DEFAULT '{}'::JSONB, -- Additional metadata (rate limits, etc)
    
    -- Add constraints
    CONSTRAINT valid_expires_at CHECK (expires_at > created_at),
    CONSTRAINT valid_prefix CHECK (prefix ~* '^[a-zA-Z0-9_-]+$'),
    CONSTRAINT valid_scopes CHECK (array_length(scopes, 1) > 0),
    
    -- Add foreign key constraints
    CONSTRAINT fk_site FOREIGN KEY (site_id) REFERENCES sites(id) ON DELETE CASCADE,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Create index for faster key lookups
CREATE INDEX idx_api_keys_prefix ON api_keys(prefix);
CREATE INDEX idx_api_keys_status ON api_keys(status);
CREATE INDEX idx_api_keys_user_id ON api_keys(user_id);
CREATE INDEX idx_api_keys_site_id ON api_keys(site_id);
CREATE INDEX idx_api_keys_key_hash ON api_keys(key_hash);

-- Function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger to update updated_at
CREATE TRIGGER update_api_keys_updated_at
    BEFORE UPDATE ON api_keys
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Function to automatically expire keys
CREATE OR REPLACE FUNCTION expire_old_api_keys()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE api_keys
    SET status = 'expired'
    WHERE status = 'active' 
    AND expires_at < CURRENT_TIMESTAMP;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically expire keys
CREATE TRIGGER check_expired_api_keys
    AFTER INSERT OR UPDATE ON api_keys
    EXECUTE FUNCTION expire_old_api_keys();

-- Enable Row Level Security
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;

-- Create policies for Row Level Security
CREATE POLICY "Users can view their own API keys"
    ON api_keys FOR SELECT
    TO authenticated
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own API keys"
    ON api_keys FOR INSERT
    TO authenticated
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own API keys"
    ON api_keys FOR UPDATE
    TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own API keys"
    ON api_keys FOR DELETE
    TO authenticated
    USING (user_id = auth.uid());

-- Function to update last_used_at
CREATE OR REPLACE FUNCTION update_api_key_last_used()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE api_keys
    SET last_used_at = CURRENT_TIMESTAMP
    WHERE id = NEW.id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update last_used_at on key usage
CREATE TRIGGER update_api_key_usage
    AFTER UPDATE OF last_used_at ON api_keys
    FOR EACH ROW
    EXECUTE FUNCTION update_api_key_last_used();

-- Comments for documentation
COMMENT ON TABLE api_keys IS 'Stores API keys for user authentication';
COMMENT ON COLUMN api_keys.key_hash IS 'Hashed version of the API key (handled by application)';
COMMENT ON COLUMN api_keys.prefix IS 'Visible prefix of the API key for identification';
COMMENT ON COLUMN api_keys.scopes IS 'Array of permission scopes granted to this key';
COMMENT ON COLUMN api_keys.metadata IS 'Additional metadata like rate limits, allowed IPs, etc';
COMMENT ON COLUMN api_keys.site_id IS 'The site this API key belongs to';

-- Rollback function
CREATE OR REPLACE FUNCTION rollback_api_keys()
RETURNS void AS $$
BEGIN
    DROP TABLE IF EXISTS api_keys CASCADE;
    DROP TYPE IF EXISTS key_status;
    DROP FUNCTION IF EXISTS update_updated_at_column();
    DROP FUNCTION IF EXISTS expire_old_api_keys();
    DROP FUNCTION IF EXISTS update_api_key_last_used();
    DROP FUNCTION IF EXISTS rollback_api_keys();
END;
$$ LANGUAGE plpgsql; 