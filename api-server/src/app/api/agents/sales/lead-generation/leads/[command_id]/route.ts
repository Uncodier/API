import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/database/supabase-client';
import { CommandFactory, ProcessorInitializer } from '@/lib/agentbase';

// Initialize the command service
const processorInitializer = ProcessorInitializer.getInstance();
processorInitializer.initialize();
const commandService = processorInitializer.getCommandService();

/**
 * Validates if a string is a valid UUID
 */
function isValidUUID(uuid: string): boolean {
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
}

/**
 * GET handler to retrieve leads generated by a specific command
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { command_id: string } }
) {
  try {
    const { command_id } = params;
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1', 10);
    const perPage = parseInt(searchParams.get('per_page') || '50', 10);
    
    // Validate the command_id
    if (!command_id || !isValidUUID(command_id)) {
      return NextResponse.json(
        { 
          success: false, 
          error: { 
            code: 'INVALID_REQUEST', 
            message: 'Invalid command_id format' 
          } 
        },
        { status: 400 }
      );
    }
    
    // First, check if the command exists
    const { data: commandData, error: commandError } = await supabaseAdmin
      .from('commands')
      .select('id, internal_id, status, site_id')
      .eq('id', command_id)
      .single();
    
    if (commandError) {
      console.error('Error fetching command:', commandError);
      return NextResponse.json(
        { 
          success: false, 
          error: { 
            code: 'DATABASE_ERROR', 
            message: 'Error retrieving command information' 
          } 
        },
        { status: 500 }
      );
    }
    
    if (!commandData) {
      return NextResponse.json(
        { 
          success: false, 
          error: { 
            code: 'COMMAND_NOT_FOUND', 
            message: 'Command not found' 
          } 
        },
        { status: 404 }
      );
    }
    
    // Check if the command has completed or if it has generated partial results
    if (commandData.status !== 'completed' && commandData.status !== 'processing') {
      return NextResponse.json(
        { 
          success: false, 
          error: { 
            code: 'COMMAND_NOT_COMPLETED', 
            message: 'Command has not generated any leads yet' 
          } 
        },
        { status: 400 }
      );
    }
    
    // Look for leads in the leads table
    const { data: dbLeads, error: dbLeadsError, count: totalLeads } = await supabaseAdmin
      .from('leads')
      .select('*', { count: 'exact' })
      .eq('command_id', command_id)
      .order('created_at', { ascending: false })
      .range((page - 1) * perPage, page * perPage - 1);
    
    if (dbLeadsError) {
      console.error('Error fetching leads from database:', dbLeadsError);
      // Continue to check internal command in case leads aren't stored in DB yet
    }
    
    // Initialize leads array with any leads found in the database
    let leads = dbLeads || [];
    
    // If no leads found in the database (or there was an error) and the command is completed,
    // try to get leads from the internal command results
    if ((!leads || leads.length === 0) && commandData.internal_id) {
      try {
        const internalCommand = await commandService.getCommandById(commandData.internal_id);
        
        if (internalCommand && internalCommand.results && internalCommand.results.length > 0) {
          // Find leads in the results
          const leadsResult = internalCommand.results.find((r: any) => 
            r.leads || (r.content && r.content.leads)
          );
          
          if (leadsResult) {
            const leadsArray = leadsResult.leads || 
                              (leadsResult.content ? leadsResult.content.leads : null);
            
            if (leadsArray && Array.isArray(leadsArray)) {
              // Format the leads to match the expected structure
              leads = leadsArray.map((lead: any) => ({
                id: lead.id || `lead_${Math.random().toString(36).substr(2, 9)}`,
                name: lead.name,
                email: lead.email,
                company: lead.company,
                position: lead.position || lead.role,
                phone: lead.phone,
                website: lead.website || lead.company_website,
                industry: lead.industry,
                company_size: lead.company_size,
                location: lead.location,
                estimated_revenue: lead.estimated_revenue || lead.revenue,
                linkedin: lead.linkedin,
                match_score: lead.match_score || lead.score || 0,
                match_reasons: lead.match_reasons || [],
                verified: lead.verified || false,
                created_at: lead.created_at || new Date().toISOString(),
                command_id: command_id,
                site_id: commandData.site_id
              }));
              
              // Apply pagination to the leads from internal command
              const start = (page - 1) * perPage;
              const end = start + perPage;
              leads = leads.slice(start, end);
            }
          }
        }
      } catch (cmdError) {
        console.error('Error retrieving internal command:', cmdError);
        // Continue with any leads found so far
      }
    }
    
    // Calculate pagination information
    const totalLeadsCount = totalLeads || leads.length;
    const totalPages = Math.ceil(totalLeadsCount / perPage);
    
    // Return the leads with pagination information
    return NextResponse.json({
      success: true,
      data: {
        command_id: command_id,
        leads: leads,
        pagination: {
          total: totalLeadsCount,
          page: page,
          per_page: perPage,
          total_pages: totalPages
        }
      }
    });
    
  } catch (error) {
    console.error('Error in lead generation leads endpoint:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: { 
          code: 'SYSTEM_ERROR', 
          message: 'An internal system error occurred' 
        } 
      },
      { status: 500 }
    );
  }
} 