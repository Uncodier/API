# Configuración de la API

Esta sección proporciona información sobre cómo configurar y personalizar el uso de la API de Site Analyzer.

## Configuración del cliente

Para utilizar la API de Site Analyzer en tu aplicación, puedes crear un cliente personalizado que maneje automáticamente las solicitudes y respuestas.

### Ejemplo de cliente en JavaScript

```javascript
class SiteAnalyzerClient {
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || 'https://tudominio.com/api';
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      ...options.headers
    };
    this.timeout = options.timeout || 30000; // 30 segundos por defecto
  }

  async analyze(url) {
    return this._request('/analyze', {
      method: 'POST',
      body: JSON.stringify({ url })
    });
  }

  async askAI(query, url = null, model = 'gpt-3.5-turbo') {
    return this._request('/ai', {
      method: 'POST',
      body: JSON.stringify({ query, url, model })
    });
  }

  async getSites(options = {}) {
    const queryParams = new URLSearchParams();
    if (options.limit) queryParams.append('limit', options.limit);
    if (options.offset) queryParams.append('offset', options.offset);
    if (options.sort) queryParams.append('sort', options.sort);
    if (options.order) queryParams.append('order', options.order);
    
    const queryString = queryParams.toString();
    const url = queryString ? `/site?${queryString}` : '/site';
    
    return this._request(url, { method: 'GET' });
  }

  async getSite(id) {
    return this._request(`/site/${id}`, { method: 'GET' });
  }

  async createSite(data) {
    return this._request('/site', {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  async deleteSite(id) {
    return this._request(`/site/${id}`, { method: 'DELETE' });
  }

  async startConversation(message, url = null, model = 'gpt-3.5-turbo') {
    return this._request('/conversation', {
      method: 'POST',
      body: JSON.stringify({ message, url, model })
    });
  }

  async continueConversation(conversationId, message) {
    return this._request('/conversation', {
      method: 'POST',
      body: JSON.stringify({ conversationId, message })
    });
  }

  async getConversation(id) {
    return this._request(`/conversation/${id}`, { method: 'GET' });
  }

  async deleteConversation(id) {
    return this._request(`/conversation/${id}`, { method: 'DELETE' });
  }

  async _request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const fetchOptions = {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers
      },
      timeout: this.timeout
    };

    try {
      const response = await fetch(url, fetchOptions);
      const data = await response.json();
      
      if (!response.ok) {
        throw {
          status: response.status,
          message: data.message || 'Error desconocido',
          data
        };
      }
      
      return data;
    } catch (error) {
      if (error instanceof TypeError && error.message === 'Failed to fetch') {
        throw {
          status: 0,
          message: 'Error de conexión. Verifica tu conexión a internet.'
        };
      }
      throw error;
    }
  }
}

// Uso del cliente
const client = new SiteAnalyzerClient({
  baseUrl: 'https://tudominio.com/api',
  headers: {
    'X-Custom-Header': 'valor-personalizado'
  }
});

// Ejemplo de uso
async function analizarSitio() {
  try {
    const resultado = await client.analyze('https://ejemplo.com');
    console.log('Análisis completado:', resultado);
  } catch (error) {
    console.error('Error al analizar el sitio:', error);
  }
}
```

## Variables de entorno

Si estás utilizando la API en un entorno de servidor, puedes configurar las siguientes variables de entorno:

```bash
# URL base de la API
API_BASE_URL=https://tudominio.com/api

# Tiempo máximo de espera para las solicitudes (en milisegundos)
API_TIMEOUT=30000

# Límites de uso (solo para despliegues propios)
API_RATE_LIMIT_REQUESTS_PER_MINUTE=60
API_RATE_LIMIT_REQUESTS_PER_DAY=1000

# Configuración de modelos de IA (solo para despliegues propios)
AI_DEFAULT_MODEL=gpt-3.5-turbo
AI_AVAILABLE_MODELS=gpt-3.5-turbo,gpt-4,claude-3-opus
```

## Configuración avanzada

### Manejo de errores personalizado

Puedes implementar un manejador de errores personalizado para gestionar diferentes tipos de errores de la API:

```javascript
function handleApiError(error) {
  if (!error.status) {
    console.error('Error de conexión:', error.message);
    // Mostrar mensaje de error de conexión al usuario
    return;
  }

  switch (error.status) {
    case 400:
      console.error('Error en la solicitud:', error.message);
      // Mostrar mensaje de error de validación al usuario
      break;
    case 404:
      console.error('Recurso no encontrado:', error.message);
      // Mostrar mensaje de recurso no encontrado al usuario
      break;
    case 429:
      console.error('Límite de solicitudes excedido:', error.message);
      // Mostrar mensaje de límite excedido al usuario
      break;
    case 500:
      console.error('Error del servidor:', error.message);
      // Mostrar mensaje de error del servidor al usuario
      break;
    default:
      console.error('Error desconocido:', error.message);
      // Mostrar mensaje de error genérico al usuario
  }
}

// Uso del manejador de errores
try {
  const resultado = await client.analyze('https://ejemplo.com');
  console.log('Análisis completado:', resultado);
} catch (error) {
  handleApiError(error);
}
```

### Caché de respuestas

Para mejorar el rendimiento y reducir el número de solicitudes a la API, puedes implementar un sistema de caché:

```javascript
class CacheManager {
  constructor(options = {}) {
    this.cache = new Map();
    this.ttl = options.ttl || 300000; // 5 minutos por defecto
  }

  set(key, value) {
    const entry = {
      value,
      expiry: Date.now() + this.ttl
    };
    this.cache.set(key, entry);
    return value;
  }

  get(key) {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value;
  }

  clear() {
    this.cache.clear();
  }
}

// Integración con el cliente de API
class SiteAnalyzerClientWithCache extends SiteAnalyzerClient {
  constructor(options = {}) {
    super(options);
    this.cache = new CacheManager(options.cache);
  }

  async _request(endpoint, options = {}) {
    // Solo cachear solicitudes GET
    if (options.method === 'GET') {
      const cacheKey = `${endpoint}`;
      const cachedResponse = this.cache.get(cacheKey);
      
      if (cachedResponse) {
        return cachedResponse;
      }
      
      const response = await super._request(endpoint, options);
      this.cache.set(cacheKey, response);
      return response;
    }
    
    return super._request(endpoint, options);
  }
} 