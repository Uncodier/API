/**
 * Plan Management Service
 * Handles plan creation, updates, and step management
 */

import { supabaseAdmin } from '@/lib/database/supabase-client';
import { completeInProgressPlans, replacePlan } from '@/lib/helpers/plan-lifecycle';

/**
 * Create a new plan for an instance
 */
export async function createNewPlanForInstance(
  instance_id: string, 
  current_plan_id: string, 
  planContent: any, 
  currentPlan: any
) {
  try {
    // Complete all in-progress plans before creating a new one
    await completeInProgressPlans(instance_id);

    // Mark current plan as replaced using the shared function
    await replacePlan(current_plan_id, 'Agent requested new plan');

    // Create the new plan
    const { data: newPlan, error: newPlanError } = await supabaseAdmin
      .from('instance_plans')
      .insert({
        instance_id: instance_id,
        title: planContent.title || 'Agent Generated Plan',
        description: planContent.description || 'Plan generated by agent',
        status: 'active',
        site_id: currentPlan.site_id,
        user_id: currentPlan.user_id,
        agent_id: currentPlan.agent_id,
        command_id: currentPlan.command_id,
        steps_total: planContent.steps?.length || 1,
        steps_completed: 0,
        progress_percentage: 0,
      })
      .select()
      .single();

    if (newPlanError) {
      console.error('Error creating new plan:', newPlanError);
      return;
    }

    // Add steps to the new plan's steps field
    if (planContent.steps && Array.isArray(planContent.steps)) {
      const planSteps = planContent.steps.map((step: any, index: number) => ({
        id: step.id || `step_${index + 1}`,
        title: step.title || `Step ${index + 1}`,
        description: step.description || step.title || `Step ${index + 1}`,
        order: step.order || index + 1,
        status: 'pending',
        type: step.type || 'task',
        instructions: step.instructions || step.description || step.title,
        expected_output: step.expected_output || '',
        actual_output: null,
        started_at: null,
        completed_at: null,
        duration_seconds: null,
        retry_count: 0,
        error_message: null,
        artifacts: []
      }));

      await supabaseAdmin
        .from('instance_plans')
        .update({ steps: planSteps })
        .eq('id', newPlan.id);
    }

    console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž New plan created with ID: ${newPlan.id}`);
    return newPlan;
  } catch (error) {
    console.error('Error creating new plan for instance:', error);
  }
}

/**
 * Update plan with step results
 */
export async function updatePlanWithStepResult(
  effective_plan_id: string,
  currentStep: any,
  stepStatus: string,
  finalResult: string,
  executionStartTime: number,
  allSteps: any[]
) {
  const planUpdateData: any = {
    updated_at: new Date().toISOString(),
  };

  // Update the current step status in steps array
  const nowISO = new Date().toISOString();
  const executionDuration = Math.round((Date.now() - executionStartTime) / 1000);
  
  // Fetch latest version of plan before updating
  console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Fetching latest version of plan ${effective_plan_id} before updating...`);
  
  const { data: latestPlan, error: fetchError } = await supabaseAdmin
    .from('instance_plans')
    .select('*')
    .eq('id', effective_plan_id)
    .single();
  
  if (fetchError || !latestPlan) {
    console.error(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Error fetching latest plan:`, fetchError);
    throw new Error(`Failed to fetch latest plan version: ${fetchError?.message}`);
  }
  
  console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Latest plan status: ${latestPlan.status}, steps: ${latestPlan.steps?.length || 0}`);
  
  // Merge with latest version - use most current steps from DB
  const latestSteps = latestPlan.steps || [];
  
  // Update only the current step in the latest version
  const finalUpdatedSteps = latestSteps.map((step: any) => {
    if (step.id === currentStep.id) {
      const updatedStep = {
        ...step,
        status: stepStatus === 'completed' ? 'completed' : 
                stepStatus === 'failed' || stepStatus === 'plan_failed' ? 'failed' : 
                stepStatus === 'canceled' ? 'cancelled' : 'in_progress',
        actual_output: finalResult,
        started_at: step.started_at || nowISO,
        duration_seconds: executionDuration,
        retry_count: (step.retry_count || 0) + (stepStatus === 'failed' ? 1 : 0),
        error_message: stepStatus === 'failed' || stepStatus === 'plan_failed' ? finalResult : null
      };
      
      // Only mark completed_at if really completed
      if (stepStatus === 'completed') {
        updatedStep.completed_at = nowISO;
      } else if (stepStatus === 'failed' || stepStatus === 'plan_failed') {
        updatedStep.completed_at = null;
      }
      
      console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Step ${step.id} updated: status=${updatedStep.status}, duration=${executionDuration}s`);
      return updatedStep;
    }
    return step;
  });
  
  planUpdateData.steps = finalUpdatedSteps;

  // Calculate progress based on completed steps
  const completedStepsCount = finalUpdatedSteps.filter((step: any) => step.status === 'completed').length;
  const totalStepsCount = finalUpdatedSteps.length;
  
  planUpdateData.steps_completed = completedStepsCount;
  planUpdateData.steps_total = totalStepsCount;
  planUpdateData.progress_percentage = Math.round((completedStepsCount / totalStepsCount) * 100);

  // Determine plan status based on steps
  const allCompleted = completedStepsCount === totalStepsCount;
  const anyFailed = finalUpdatedSteps.some((step: any) => step.status === 'failed');
  
  console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Plan status check: stepStatus=${stepStatus}, allCompleted=${allCompleted}, completedStepsCount=${completedStepsCount}, totalStepsCount=${totalStepsCount}`);
  
  // Simplified logic: If all steps are completed, plan is completed
  if (allCompleted) {
    planUpdateData.status = 'completed';
    planUpdateData.completed_at = new Date().toISOString();
    console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž âœ… Plan marked as COMPLETED - all ${totalStepsCount} steps finished`);
  } else if (stepStatus === 'failed' || stepStatus === 'plan_failed' || anyFailed) {
    planUpdateData.status = 'failed';
    planUpdateData.error_message = finalResult;
    console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž âŒ Plan marked as FAILED - reason: ${finalResult}`);
  } else if (stepStatus === 'canceled') {
    planUpdateData.status = 'cancelled';
    planUpdateData.completed_at = new Date().toISOString();
    console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž â¸ï¸ Plan marked as CANCELLED`);
  } else {
    planUpdateData.status = 'in_progress';
    console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž ðŸ”„ Plan continues as IN_PROGRESS - ${completedStepsCount}/${totalStepsCount} steps completed`);
  }

  console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž About to update plan ${effective_plan_id} with latest version:`, {
    status: planUpdateData.status,
    steps_completed: planUpdateData.steps_completed,
    steps_total: planUpdateData.steps_total,
    progress_percentage: planUpdateData.progress_percentage,
    updated_steps_count: finalUpdatedSteps.length
  });

  const updateResult = await supabaseAdmin
    .from('instance_plans')
    .update(planUpdateData)
    .eq('id', effective_plan_id);
    
  if (updateResult.error) {
    console.error(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Error updating plan:`, updateResult.error);
  } else {
    console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Plan updated successfully`);
  }

  return planUpdateData;
}

/**
 * Mark plan as started before execution
 */
export async function markPlanAsStarted(
  effective_plan_id: string,
  planSteps: any[],
  currentStep: any
) {
  console.log(`â‚á¢â€¢(Ü«)â€¢á¢â‚Ž Marking plan as in_progress and current step as started before execution`);
  
  // Mark current step as started/in_progress before execution
  const updatedStepsForStart = planSteps.map((step: any) => {
    if (step.id === currentStep.id) {
      return {
        ...step,
        status: 'in_progress',
        started_at: new Date().toISOString()
      };
    }
    return step;
  });
  
  await supabaseAdmin
    .from('instance_plans')
    .update({ 
      status: 'in_progress', 
      started_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      steps: updatedStepsForStart
    })
    .eq('id', effective_plan_id);
}

/**
 * Get current step from plan steps
 */
export function getCurrentStep(planSteps: any[]) {
  // Find first pending step, prioritizing by order
  const currentStep = planSteps
    .filter((step: any) => step.status === 'pending')
    .sort((a: any, b: any) => (a.order || 0) - (b.order || 0))[0];
  
  return currentStep;
}

/**
 * Check if plan is completed
 */
export function isPlanFullyCompleted(planSteps: any[]) {
  const completedSteps = planSteps.filter((step: any) => step.status === 'completed');
  return completedSteps.length === planSteps.length;
}
